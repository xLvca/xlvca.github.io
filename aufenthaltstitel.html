<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Aufenthaltstitel Scanner</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
  body {
    margin: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
      Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 1rem 0 2rem;
  }
  h1 {
    margin: 0 0 12px;
    font-weight: 700;
    font-size: 1.6rem;
    letter-spacing: 0.04em;
    text-shadow: 0 2px 6px rgba(0,0,0,0.4);
  }
  #video-container {
    position: relative;
    width: 90vw;
    max-width: 400px;
    aspect-ratio: 5/3;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 10px 20px rgba(0,0,0,0.5);
    background: #000;
  }
  video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  /* Scan-Rahmen Overlay - minimal weiß, kein pulsieren */
  #frame {
    pointer-events: none;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 85%;
    height: 58%;
    max-width: 340px;
    max-height: 200px;
    transform: translate(-50%, -50%);
    border: 2px solid rgba(255,255,255,0.85);
    border-radius: 12px;
    box-shadow: inset 0 0 12px 1px rgba(255,255,255,0.3);
    backdrop-filter: brightness(0.85);
  }
  #controls {
    margin-top: 1rem;
    display: flex;
    gap: 12px;
    justify-content: center;
  }
  button {
    background: #2980b9;
    border: none;
    border-radius: 8px;
    padding: 0.65rem 1.6rem;
    font-weight: 600;
    font-size: 1rem;
    color: white;
    cursor: pointer;
    box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    transition: background-color 0.25s ease;
    flex: 1;
  }
  button[aria-pressed="true"] {
    background: #27ae60;
    box-shadow: 0 4px 10px rgba(39,174,96,0.7);
  }
  button:hover {
    background-color: #1f6391;
  }
  #scanBtn {
    margin-top: 1rem;
    width: 90vw;
    max-width: 400px;
    background: #e67e22;
    box-shadow: 0 4px 12px rgba(230,126,34,0.8);
    font-weight: 700;
  }
  #flashBtn {
    position: absolute;
    top: 12px;
    right: 12px;
    background: rgba(255 255 255 / 0.3);
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
    font-size: 24px;
    box-shadow: 0 0 12px rgba(255,255,255,0.7);
    cursor: pointer;
    user-select: none;
    transition: background-color 0.3s ease;
    z-index: 10;
  }
  #flashBtn.active {
    background: #f1c40f;
    color: #2c3e50;
    box-shadow: 0 0 20px #f1c40f;
  }
  #status {
    margin-top: 1rem;
    font-size: 1rem;
    font-weight: 600;
    min-height: 24px;
    text-align: center;
    color: #f1c40f;
    text-shadow: 0 0 3px rgba(0,0,0,0.7);
  }
  #result {
    margin-top: 1rem;
    background: rgba(255 255 255 / 0.15);
    border-radius: 12px;
    padding: 1rem;
    color: #ecf0f1;
    min-height: 100px;
    white-space: pre-wrap;
    font-size: 1rem;
    font-weight: 500;
    user-select: text;
  }
</style>
</head>
<body>

<h1>Aufenthaltstitel Scanner</h1>

<div id="video-container">
  <video id="video" autoplay playsinline></video>
  <div id="frame"></div>
  <div id="flashBtn" title="Blitz Ein/Aus" aria-pressed="false" role="button" tabindex="0">⚡</div>
</div>

<div id="controls" role="radiogroup" aria-label="Dokumentseite wählen">
  <button id="frontBtn" aria-pressed="true" role="radio">Vorderseite</button>
  <button id="backBtn" aria-pressed="false" role="radio">Rückseite</button>
</div>

<button id="scanBtn" aria-live="polite" aria-label="Scan starten">Scan starten</button>

<div id="status" aria-live="polite" role="status">Bitte Vorderseite scannen</div>

<pre id="result" aria-live="polite"></pre>

<canvas id="canvas" style="display:none;"></canvas>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<script>
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const statusDiv = document.getElementById('status');
  const resultDiv = document.getElementById('result');

  const frontBtn = document.getElementById('frontBtn');
  const backBtn = document.getElementById('backBtn');
  const scanBtn = document.getElementById('scanBtn');
  const flashBtn = document.getElementById('flashBtn');

  let currentSide = 'front';
  let streamTrack = null;
  let torchOn = false;

  function setSide(side) {
    currentSide = side;
    if (side === 'front') {
      frontBtn.setAttribute('aria-pressed', 'true');
      backBtn.setAttribute('aria-pressed', 'false');
      statusDiv.textContent = 'Bitte Vorderseite scannen. ' +
        'Achte auf „GEBURTSDATUM“ oder „DATE OF BIRTH“ und Dokumentnummer oben rechts.';
      resultDiv.textContent = '';
    } else {
      frontBtn.setAttribute('aria-pressed', 'false');
      backBtn.setAttribute('aria-pressed', 'true');
      statusDiv.textContent = 'Bitte Rückseite scannen. ' +
        'Achte auf MRZ-Muster (<<<<<) und Adresse unten rechts.';
      resultDiv.textContent = '';
    }
  }

  frontBtn.onclick = () => setSide('front');
  backBtn.onclick = () => setSide('back');

  async function setupCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' },
        audio: false
      });
      video.srcObject = stream;
      streamTrack = stream.getVideoTracks()[0];
      return new Promise(resolve => {
        video.onloadedmetadata = () => resolve();
      });
    } catch (err) {
      statusDiv.textContent = 'Kamera kann nicht geöffnet werden: ' + err.message;
    }
  }

  // Torch/Blitz Umschalten (nur wenn unterstützt)
  async function toggleFlash() {
    if (!streamTrack) return;
    const capabilities = streamTrack.getCapabilities();
    if (!capabilities.torch) {
      alert('Blitz wird von dieser Kamera nicht unterstützt.');
      return;
    }
    try {
      torchOn = !torchOn;
      await streamTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
      flashBtn.classList.toggle('active', torchOn);
      flashBtn.setAttribute('aria-pressed', torchOn.toString());
    } catch (err) {
      alert('Fehler beim Umschalten des Blitzes: ' + err.message);
    }
  }

  flashBtn.onclick = toggleFlash;
  flashBtn.onkeydown = e => { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleFlash(); } };

  // Bildvorverarbeitung: Beschneide auf Rahmen, erhöhe Kontrast + Schärfe (leicht)
  function preprocessImage() {
    // Rahmen relativ zum Video
    const frame = document.getElementById('frame');
    const videoRect = video.getBoundingClientRect();
    const frameRect = frame.getBoundingClientRect();

    // Berechne crop Bereich relativ zu Video Größe
    const scaleX = video.videoWidth / videoRect.width;
    const scaleY = video.videoHeight / videoRect.height;

    const cropX = (frameRect.left - videoRect.left) * scaleX;
    const cropY = (frameRect.top - videoRect.top) * scaleY;
    const cropW = frameRect.width * scaleX;
    const cropH = frameRect.height * scaleY;

    // Setze Canvas Größe auf crop Größe
    canvas.width = cropW;
    canvas.height = cropH;

    // Zeichne ausgeschnittenes Bild auf Canvas
    ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

    // Hol Bilddaten, erhöhe Kontrast + Schärfe leicht (Kernel)
    let imageData = ctx.getImageData(0, 0, cropW, cropH);
    let data = imageData.data;

    // Kontrast erhöhen
    const contrast = 1.4; // 1=neutral, >1 kontrast erhöhen
    const intercept = 128 * (1 - contrast);

    for (let i = 0; i < data.length; i += 4) {
      for (let c = 0; c < 3; c++) {
        data[i + c] = Math.min(255, Math.max(0, contrast * data[i + c] + intercept));
      }
    }

    // Einfacher Schärfe-Filter (unsharp mask - rudimentär)
    // Convolution Kernel (3x3) für leichte Schärfe
    const kernel = [
      0, -1, 0,
      -1, 5, -1,
      0, -1, 0
    ];
    const w = cropW;
    const h = cropH;
    const copy = new Uint8ClampedArray(data);

    for (let y = 1; y < h -1; y++) {
      for (let x = 1; x < w -1; x++) {
        for (let c = 0; c < 3; c++) {
          let sum = 0;
          let idx = (y*w + x)*4 + c;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <=1; kx++) {
              let kidx = (ky+1)*3 + (kx+1);
              let pxidx = ((y+ky)*w + (x+kx))*4 + c;
              sum += copy[pxidx] * kernel[kidx];
            }
          }
          data[idx] = Math.min(255, Math.max(0, sum));
        }
      }
    }

    ctx.putImageData(imageData, 0, 0);
  }

  // Parsing Funktionen (wie vorher, leicht erweitert & angepasst)
  function parseDate(day, month, year) {
    // Prüfe Plausibilität und formatiere yyyy-mm-dd
    day = parseInt(day,10);
    month = parseInt(month,10);
    year = parseInt(year,10);
    if (year < 1900 || year > 2100) return null;
    if (month < 1 || month > 12) return null;
    if (day < 1 || day > 31) return null;
    // Einfache Prüfung: keine 31.02 etc. hier
    return `${year.toString().padStart(4,'0')}-${month.toString().padStart(2,'0')}-${day.toString().padStart(2,'0')}`;
  }

  function parseFront(text) {
    const data = {};
    text = text.toUpperCase();

    // GEBURTSDATUM oder DATE OF BIRTH (Datum direkt dahinter oder in der nächsten Zeile)
    let dobMatch = text.match(/(GEBURTSDATUM|DATE OF BIRTH)[\s:\-]*([0-3]?\d)[\s.\-\/]([01]?\d)[\s.\-\/](\d{4})/);
    if (!dobMatch) {
      // Falls Datum in nächster Zeile: Splitt nach Zeilen und suche nach DOB, dann in nächster Zeile Datum
      let lines = text.split('\n');
      for(let i=0; i<lines.length; i++) {
        if (lines[i].includes('GEBURTSDATUM') || lines[i].includes('DATE OF BIRTH')) {
          let possibleDate = lines[i+1] || '';
          let dateMatch = possibleDate.match(/([0-3]?\d)[\s.\-\/]([01]?\d)[\s.\-\/](\d{4})/);
          if (dateMatch) {
            dobMatch = [null,null,dateMatch[1], dateMatch[2], dateMatch[3]];
            break;
          }
        }
      }
    }
    if (dobMatch) {
      let isoDate = parseDate(dobMatch[2], dobMatch[3], dobMatch[4]);
      if (isoDate) data.DOB = isoDate;
    }

    // Dokumentnummer oben rechts: Suche nach typischen Labels + 8-12 Alphanumerisch
    let docNrMatch = text.match(/(DOKUMENTNUMMER|DOCUMENT NUMBER|DOC NR|NR)[\s:\-]*([A-Z0-9]{8,12})/);
    if (docNrMatch) {
      data.DocumentNumber = docNrMatch[2];
    } else {
      // Fallback Suche nach 8-12 Alphanumerisch in der Nähe oben rechts (erste Zeilen)
      let firstLines = text.split('\n').slice(0,8).join('\n');
      let altDocNr = firstLines.match(/[A-Z0-9]{8,12}/);
      if (altDocNr) data.DocumentNumber = altDocNr[0];
    }

    // Seriennummer unten rechts: 5-10 alphanumerisch, Label SN, SERIAL, SERIENNUMMER, NR
    let serNrMatch = text.match(/(SERIAL|SERIENNUMMER|SN|NR)[\s:\-]*([A-Z0-9]{5,10})/);
    if (serNrMatch) {
      data.SerialNumber = serNrMatch[2];
    }

    return data;
  }

  function parseBack(text) {
    const data = {};
    text = text.toUpperCase();

    // MRZ mit mind. 2 < Zeichen pro Zeile erkennen
    let mrzLines = text.split('\n').filter(line => (line.match(/</g) || []).length >= 2);
    if (mrzLines.length > 0) data.MRZ = mrzLines.join('\n');

    // Adresse: 5-stellige PLZ + Ort
    let addrMatch = text.match(/(\d{5})\s+([A-ZÄÖÜß\s\-]+)/);
    if (addrMatch) data.Address = addrMatch[0].trim();

    // Ausstellungsdatum (optional)
    let issueMatch = text.match(/(AUSSTELLUNGSDATUM|ISSUE DATE)[\s:\-]*([0-3]?\d)[\s.\-\/]([01]?\d)[\s.\-\/](\d{4})/);
    if (issueMatch) {
      let isoDate = parseDate(issueMatch[2], issueMatch[3], issueMatch[4]);
      if (isoDate) data.IssueDate = isoDate;
    }

    return data;
  }

  function formatOutput(data, side) {
    if (!data || Object.keys(data).length === 0) {
      if (side === 'front') {
        return "Keine relevanten Daten erkannt.\nBitte still halten und Vorderseite korrekt positionieren.";
      } else {
        return "Keine relevanten Daten erkannt.\nBitte Rückseite korrekt positionieren.";
      }
    }
    let out = '';
    if (data.DOB) out += `Geburtsdatum: ${data.DOB}\n`;
    if (data.DocumentNumber) out += `Dokumentnummer: ${data.DocumentNumber}\n`;
    if (data.SerialNumber) out += `Seriennummer: ${data.SerialNumber}\n`;
    if (data.MRZ) out += `MRZ:\n${data.MRZ}\n`;
    if (data.Address) out += `Adresse: ${data.Address}\n`;
    if (data.IssueDate) out += `Ausstellungsdatum: ${data.IssueDate}\n`;
    return out.trim();
  }

  // OCR Retry & Scan Optimierung
  async function doOCR() {
    statusDiv.textContent = 'Bild wird aufgenommen... Bitte still halten!';
    resultDiv.textContent = '';
    preprocessImage();

    let lastResult = '';
    let tries = 0;
    const maxTries = 3;

    while(tries < maxTries) {
      try {
        const { data: { text } } = await Tesseract.recognize(canvas, 'deu', {
          logger: m => {
            if (m.status === 'recognizing text') {
              statusDiv.textContent = `OCR: ${Math.round(m.progress * 100)}% - Bitte still halten! (${tries+1}/${maxTries})`;
            }
          }
        });

        let parsedData;
        if (currentSide === 'front') parsedData = parseFront(text);
        else parsedData = parseBack(text);

        const output = formatOutput(parsedData, currentSide);

        if (output !== lastResult && output.indexOf('Keine relevanten Daten erkannt') === -1) {
          statusDiv.textContent = 'Scan abgeschlossen.';
          resultDiv.textContent = output;
          return;
        }
        lastResult = output;
      } catch (err) {
        statusDiv.textContent = 'Fehler bei OCR: ' + err.message;
        break;
      }
      tries++;
      await new Promise(r => setTimeout(r, 1000)); // 1 Sek Pause vor Retry
    }
    // Falls keine guten Daten nach retries:
    statusDiv.textContent = 'Leider keine klaren Daten erkannt.\nBitte nochmal versuchen und ruhig halten.';
    resultDiv.textContent = lastResult || '';
  }

  scanBtn.onclick = doOCR;

  setupCamera();
  setSide('front');
</script>

</body>
</html>
